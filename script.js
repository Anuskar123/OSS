// Operating Systems Comprehensive Quiz - 60 Questions
const questions = [
    {
        id: 1,
        question: "In UNIX file permissions `-rwxr-xr--`, what does the first character represent?",
        options: [
            "Read permission for owner",
            "Regular file type",
            "Root access indicator", 
            "Recursive permission flag"
        ],
        correctAnswer: 1,
        explanation: "The first character in UNIX file permissions indicates the file type. A hyphen (-) indicates a regular file, while 'd' would indicate a directory. The remaining 9 characters represent permissions for owner, group, and others (3 characters each).",
        category: "Access Rights & File Permissions"
    },
    {
        id: 2,
        question: "What is the numeric equivalent of permissions `rwx` for the owner?",
        options: [
            "6",
            "7",
            "8",
            "9"
        ],
        correctAnswer: 1,
        explanation: "In UNIX, read=4, write=2, execute=1. So rwx = 4+2+1 = 7. This numeric notation allows quick permission setting with commands like `chmod 755 filename`.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 3,
        question: "The command `chmod go-rwx filename` will:",
        options: [
            "Give read, write, execute to group and others",
            "Remove read, write, execute from group and others",
            "Set read, write, execute for group and others",
            "Only affect the group permissions"
        ],
        correctAnswer: 1,
        explanation: "The 'go' refers to group and others, the '-' means remove, and 'rwx' are the permissions being removed. This command removes all permissions from group and other users while leaving owner permissions unchanged.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 4,
        question: "Which file system service is NOT typically provided by operating systems?",
        options: [
            "Create a file",
            "Read from an open file",
            "Compile source code",
            "Modify file metadata"
        ],
        correctAnswer: 2,
        explanation: "Compilation is handled by compilers, not the file system. File systems provide basic operations like create, read, write, open, close, and metadata management, but not language-specific operations like compilation.",
        category: "File Systems & Management"
    },
    {
        id: 5,
        question: "What is the main advantage of treating all I/O devices as files in UNIX?",
        options: [
            "Faster performance",
            "Uniform interface for all devices",
            "Better security",
            "Reduced memory usage"
        ],
        correctAnswer: 1,
        explanation: "UNIX treats terminals, disk drives, pipes, and other devices as files, providing a uniform interface. This means the same system calls (read, write, open, close) work for all devices, simplifying programming.",
        category: "File Systems & Management"
    },
    {
        id: 6,
        question: "In file locking, what is the difference between exclusive and shared access?",
        options: [
            "Exclusive allows one writer, shared allows multiple readers",
            "Exclusive is faster than shared",
            "Shared access requires more memory",
            "There is no practical difference"
        ],
        correctAnswer: 0,
        explanation: "Exclusive access prevents other processes from accessing the file (typically for writing), while shared access allows multiple processes to read simultaneously. This prevents data corruption during writes while allowing concurrent reads.",
        category: "File Systems & Management"
    },
    {
        id: 7,
        question: "What is the primary purpose of the Memory Management Unit (MMU)?",
        options: [
            "Increase memory speed",
            "Translate logical addresses to physical addresses",
            "Compress memory contents",
            "Manage cache memory"
        ],
        correctAnswer: 1,
        explanation: "The MMU translates virtual/logical addresses generated by the CPU into actual physical memory addresses. This enables virtual memory, memory protection, and allows programs to use addresses independent of their physical location.",
        category: "Memory Management"
    },
    {
        id: 8,
        question: "In fixed partition memory allocation, what is internal fragmentation?",
        options: [
            "Unused space between partitions",
            "Unused space within allocated partitions",
            "Fragmented files on disk",
            "Memory leaks in programs"
        ],
        correctAnswer: 1,
        explanation: "Internal fragmentation occurs when allocated memory blocks contain unused space. In fixed partitions, if a 100KB process is allocated to a 150KB partition, the 50KB unused space is internal fragmentation.",
        category: "Memory Management"
    },
    {
        id: 9,
        question: "What is the main advantage of dynamic address binding over static binding?",
        options: [
            "Faster execution",
            "Programs can be relocated in memory",
            "Uses less memory",
            "Simpler to implement"
        ],
        correctAnswer: 1,
        explanation: "Dynamic binding allows programs to be loaded at any memory location and moved during execution. Static binding fixes addresses at compile/link time, requiring programs to be loaded at specific memory locations.",
        category: "Memory Management"
    },
    {
        id: 10,
        question: "In paging, if logical address is 0x12345 with 4KB pages, what is the page number?",
        options: [
            "0x12",
            "0x123",
            "0x1234",
            "0x345"
        ],
        correctAnswer: 0,
        explanation: "With 4KB (4096 = 2^12) pages, the lower 12 bits (0x345) represent the offset within the page, and the upper bits (0x12) represent the page number. The page number is used for address translation.",
        category: "Memory Management"
    },
    {
        id: 11,
        question: "What is the primary benefit of virtual memory?",
        options: [
            "Faster memory access",
            "Ability to run programs larger than physical memory",
            "Better graphics performance",
            "Reduced power consumption"
        ],
        correctAnswer: 1,
        explanation: "Virtual memory allows execution of programs that exceed physical RAM size by using disk storage as an extension of memory. Pages are swapped between RAM and disk as needed.",
        category: "Virtual Memory"
    },
    {
        id: 12,
        question: "In a virtual memory system with page size 4KB, how many bits are needed for the page offset?",
        options: [
            "10 bits",
            "12 bits",
            "14 bits",
            "16 bits"
        ],
        correctAnswer: 1,
        explanation: "4KB = 4096 bytes = 2^12 bytes. Therefore, 12 bits are needed to address all bytes within a 4KB page (0 to 4095).",
        category: "Virtual Memory"
    },
    {
        id: 13,
        question: "When two logical pages map to the same physical page, this typically indicates:",
        options: [
            "A memory error",
            "Shared memory or code",
            "Virtual memory failure",
            "Page fault condition"
        ],
        correctAnswer: 1,
        explanation: "Multiple logical pages mapping to the same physical page allows processes to share code (like libraries) or data, reducing memory usage while maintaining separate virtual address spaces.",
        category: "Virtual Memory"
    },
    {
        id: 14,
        question: "What is the computational state of a process?",
        options: [
            "The process priority level",
            "Internal snapshot of CPU registers and resources at an instant",
            "The process memory usage",
            "The process execution time"
        ],
        correctAnswer: 1,
        explanation: "The computational state includes CPU registers, program counter, stack pointer, and other processor state information that must be saved when the process is switched out and restored when it resumes.",
        category: "Process Management"
    },
    {
        id: 15,
        question: "In the five-state process model, what is the difference between \"Ready\" and \"Blocked\" states?",
        options: [
            "Ready processes are running, blocked are waiting",
            "Ready processes can run immediately, blocked are waiting for I/O",
            "Ready processes have higher priority",
            "There is no practical difference"
        ],
        correctAnswer: 1,
        explanation: "Ready processes are waiting in the queue for CPU time and can run immediately when scheduled. Blocked processes are waiting for some event (like I/O completion) and cannot run until that event occurs.",
        category: "Process Management"
    },
    {
        id: 16,
        question: "What is the purpose of the \"New\" state in the five-state process model?",
        options: [
            "Process is being created but not yet ready to run",
            "Process has just started executing",
            "Process is waiting for user input",
            "Process is being terminated"
        ],
        correctAnswer: 0,
        explanation: "The New state represents processes that have been created (allocated PID, process control block) but haven't been admitted to the pool of executable processes yet, often due to system limits on concurrent processes.",
        category: "Process Management"
    },
    {
        id: 17,
        question: "Why might an operating system move a blocked process to a suspend state?",
        options: [
            "To free up memory for new processes",
            "To increase process priority",
            "To debug the process",
            "To improve security"
        ],
        correctAnswer: 0,
        explanation: "Suspending blocked processes moves them to disk storage, freeing up main memory. This allows new processes to be loaded or ready processes to have more memory available, improving overall system performance.",
        category: "Process Management"
    },
    {
        id: 18,
        question: "What is the main difference between preemptive and cooperative multitasking?",
        options: [
            "Speed of execution",
            "Whether the OS can forcibly stop running processes",
            "Number of processes that can run",
            "Memory usage"
        ],
        correctAnswer: 1,
        explanation: "In preemptive multitasking, the OS can forcibly stop (preempt) a running process to schedule another. In cooperative multitasking, processes must voluntarily yield control, which can lead to system hangs if a process doesn't cooperate.",
        category: "CPU Scheduling"
    },
    {
        id: 19,
        question: "Why does Linux favor I/O-bound processes in scheduling?",
        options: [
            "They use less memory",
            "They provide better interactive response",
            "They are more important",
            "They execute faster"
        ],
        correctAnswer: 1,
        explanation: "I/O-bound processes (like interactive applications) typically run for short bursts before waiting for I/O. Favoring them ensures quick response to user interactions, making the system feel more responsive.",
        category: "CPU Scheduling"
    },
    {
        id: 20,
        question: "What happens when a process's timeslice expires in Linux?",
        options: [
            "The process is terminated",
            "The process becomes expired and can't run until others exhaust their timeslices",
            "The process priority is lowered",
            "The process is moved to blocked state"
        ],
        correctAnswer: 1,
        explanation: "When a process uses up its timeslice, it becomes \"expired\" and cannot run until all other processes have also exhausted their timeslices, at which point all timeslices are recalculated.",
        category: "CPU Scheduling"
    },
    {
        id: 21,
        question: "Why is a very short timeslice problematic for system performance?",
        options: [
            "Processes cannot complete their work",
            "Too much time is spent on context switching overhead",
            "Memory usage increases",
            "I/O performance degrades"
        ],
        correctAnswer: 1,
        explanation: "Very short timeslices cause frequent context switches between processes. The overhead of saving and restoring process state becomes a significant portion of CPU time, reducing overall system throughput.",
        category: "CPU Scheduling"
    },
    {
        id: 22,
        question: "What is a race condition?",
        options: [
            "Competition between processes for CPU time",
            "When multiple processes access shared data and the result depends on execution order",
            "When one process runs faster than another",
            "When processes compete for memory allocation"
        ],
        correctAnswer: 1,
        explanation: "A race condition occurs when the outcome of a program depends on the relative timing or interleaving of multiple processes/threads accessing shared resources, leading to unpredictable and potentially incorrect results.",
        category: "Inter-Process Communication"
    },
    {
        id: 23,
        question: "What is the main problem that semaphores solve?",
        options: [
            "Memory allocation",
            "Process scheduling",
            "Mutual exclusion and synchronization",
            "File system access"
        ],
        correctAnswer: 2,
        explanation: "Semaphores provide a mechanism for controlling access to shared resources, ensuring mutual exclusion (only one process in critical section) and enabling process synchronization for coordinated execution.",
        category: "Inter-Process Communication"
    },
    {
        id: 24,
        question: "In the context of the three types of process interaction, which is the most complex to manage?",
        options: [
            "Processes competing for resources",
            "Processes cooperating by communication",
            "Independent processes",
            "All are equally complex"
        ],
        correctAnswer: 1,
        explanation: "Cooperating processes that share data and communicate are most complex because they require careful synchronization to avoid race conditions, deadlocks, and ensure data consistency while maintaining correct communication protocols.",
        category: "Inter-Process Communication"
    },
    {
        id: 25,
        question: "What is the difference between synchronous and asynchronous signals?",
        options: [
            "Synchronous signals are faster",
            "Synchronous signals occur at predictable points, asynchronous are random",
            "Asynchronous signals are more important",
            "Synchronous signals require special hardware"
        ],
        correctAnswer: 1,
        explanation: "Synchronous signals (like divide-by-zero, illegal instruction) occur at specific, predictable points in program execution. Asynchronous signals (like SIGINT from Ctrl+C, timer expiration) can occur at any time unpredictably.",
        category: "Signals"
    },
    {
        id: 26,
        question: "What does the signal() function call `signal(SIGINT, SIG_IGN)` do?",
        options: [
            "Catches SIGINT with a custom handler",
            "Ignores SIGINT signals",
            "Restores default SIGINT behavior",
            "Sends SIGINT to another process"
        ],
        correctAnswer: 1,
        explanation: "SIG_IGN tells the system to ignore the specified signal (SIGINT in this case). The process will continue running even when SIGINT is received, such as when Ctrl+C is pressed.",
        category: "Signals"
    },
    {
        id: 27,
        question: "Which signal cannot be caught or ignored?",
        options: [
            "SIGINT",
            "SIGTERM",
            "SIGKILL",
            "SIGALARM"
        ],
        correctAnswer: 2,
        explanation: "SIGKILL cannot be caught, ignored, or blocked by a process. It provides a guaranteed way for the system or users to terminate processes that are not responding to other termination signals.",
        category: "Signals"
    },
    {
        id: 28,
        question: "What typically happens when Ctrl+C is pressed in a terminal?",
        options: [
            "SIGTERM is sent to the foreground process",
            "SIGINT is sent to the foreground process",
            "SIGKILL is sent to all processes",
            "SIGHUP is sent to the shell"
        ],
        correctAnswer: 1,
        explanation: "Ctrl+C generates a SIGINT (interrupt) signal that is sent to the foreground process group. The default action is to terminate the process, but programs can catch this signal to perform cleanup operations.",
        category: "Signals"
    },
    {
        id: 29,
        question: "What is a pipe in UNIX?",
        options: [
            "A hardware component",
            "A file used as a communication buffer between processes",
            "A memory allocation technique",
            "A process scheduling algorithm"
        ],
        correctAnswer: 1,
        explanation: "A pipe is a special file that acts as a queuing buffer, allowing the output of one process to serve as input to another process, enabling inter-process communication through a FIFO (first-in-first-out) mechanism.",
        category: "IPC Mechanisms"
    },
    {
        id: 30,
        question: "In the command `ls | grep txt`, what is the role of the pipe?",
        options: [
            "It stores the output permanently",
            "It connects the output of ls to the input of grep",
            "It sorts the output",
            "It filters duplicate entries"
        ],
        correctAnswer: 1,
        explanation: "The pipe (|) connects the standard output of the `ls` command to the standard input of `grep txt`, allowing grep to filter the directory listing to show only files containing \"txt\" in their names.",
        category: "IPC Mechanisms"
    },
    {
        id: 31,
        question: "What are the three main components of System V IPC?",
        options: [
            "Pipes, signals, and sockets",
            "Semaphores, message queues, and shared memory",
            "Files, directories, and devices",
            "Processes, threads, and tasks"
        ],
        correctAnswer: 1,
        explanation: "System V IPC provides three main mechanisms: semaphores for synchronization, message queues for message passing, and shared memory for high-speed data sharing between processes.",
        category: "IPC Mechanisms"
    },
    {
        id: 32,
        question: "What is the main advantage of shared memory over message passing?",
        options: [
            "Better security",
            "Easier to use",
            "Higher performance/speed",
            "More reliable"
        ],
        correctAnswer: 2,
        explanation: "Shared memory allows processes to communicate by directly accessing shared memory regions, avoiding the overhead of copying data through kernel buffers that message passing requires, making it the fastest IPC mechanism.",
        category: "IPC Mechanisms"
    },
    {
        id: 33,
        question: "What are the four necessary conditions for deadlock?",
        options: [
            "Mutual exclusion, hold and wait, no preemption, circular wait",
            "Competition, cooperation, communication, coordination",
            "Create, read, update, delete",
            "Ready, running, blocked, suspended"
        ],
        correctAnswer: 0,
        explanation: "These four conditions must all be present for deadlock: resources must be mutually exclusive, processes hold resources while waiting for others, resources cannot be preempted, and there must be a circular chain of processes waiting for each other's resources.",
        category: "Synchronization & Deadlocks"
    },
    {
        id: 34,
        question: "Which deadlock prevention strategy involves resource preemption?",
        options: [
            "Eliminating mutual exclusion",
            "Eliminating hold and wait",
            "Eliminating no preemption",
            "Eliminating circular wait"
        ],
        correctAnswer: 2,
        explanation: "Eliminating the \"no preemption\" condition means allowing the system to forcibly take resources away from processes, though this is only practical for certain types of resources like CPU time, not for resources like printers.",
        category: "Synchronization & Deadlocks"
    },
    {
        id: 35,
        question: "What is the main advantage of hierarchical directory structures over flat directories?",
        options: [
            "Faster file access",
            "Better organization and namespace management",
            "Less memory usage",
            "Improved security"
        ],
        correctAnswer: 1,
        explanation: "Hierarchical directories allow logical organization of files into groups and enable the same filename to exist in different directories, effectively expanding the namespace and making file management more organized.",
        category: "File Organization"
    },
    {
        id: 36,
        question: "In UNIX, what does the root directory \"/\" represent?",
        options: [
            "The current user's home directory",
            "The top-level directory of the entire file system",
            "The system configuration directory",
            "The temporary files directory"
        ],
        correctAnswer: 1,
        explanation: "The root directory (/) is the top-level directory in UNIX file systems. All other directories and files are contained within this directory structure, forming a single unified tree hierarchy.",
        category: "File Organization"
    },
    {
        id: 37,
        question: "What is the purpose of device drivers in operating systems?",
        options: [
            "To speed up device access",
            "To provide device-specific interfaces to the generic I/O subsystem",
            "To encrypt device communications",
            "To manage device power consumption"
        ],
        correctAnswer: 1,
        explanation: "Device drivers act as translators between the generic I/O subsystem and specific hardware devices, hiding device-specific details and providing a uniform interface that the operating system can use.",
        category: "I/O & Device Management"
    },
    {
        id: 38,
        question: "Why does UNIX treat devices as files?",
        options: [
            "To save memory",
            "To provide uniform access methods for all I/O",
            "To improve performance",
            "To enhance security"
        ],
        correctAnswer: 1,
        explanation: "By representing devices as special files in the file system, UNIX allows the same system calls (open, read, write, close) to work with files, terminals, printers, and other devices, simplifying programming and system design.",
        category: "I/O & Device Management"
    },
    {
        id: 39,
        question: "How do base and limit registers provide memory protection?",
        options: [
            "By encrypting memory contents",
            "By checking that all memory accesses fall within allocated bounds",
            "By compressing memory to save space",
            "By speeding up memory access"
        ],
        correctAnswer: 1,
        explanation: "The base register contains the starting address of a process's memory region, and the limit register contains the size. The MMU checks that all memory references fall within [base, base+limit) to prevent processes from accessing each other's memory.",
        category: "Memory Protection"
    },
    {
        id: 40,
        question: "What is the primary purpose of memory segmentation?",
        options: [
            "To increase memory speed",
            "To provide logical division of memory spaces",
            "To reduce memory usage",
            "To simplify programming"
        ],
        correctAnswer: 1,
        explanation: "Segmentation divides a program's memory into logical segments (code, data, stack, heap) with different properties and protection levels, providing better organization and security than a single linear address space.",
        category: "Memory Protection"
    },
    {
        id: 41,
        question: "What is the main difference between system calls and library functions?",
        options: [
            "System calls are faster",
            "System calls require kernel mode transition, library functions don't",
            "Library functions are more secure",
            "System calls use less memory"
        ],
        correctAnswer: 1,
        explanation: "System calls require switching from user mode to kernel mode to access operating system services, while library functions execute entirely in user mode. This makes system calls more expensive but necessary for accessing protected resources.",
        category: "System Calls"
    },
    {
        id: 42,
        question: "Which of the following is typically implemented as a system call?",
        options: [
            "Mathematical calculations",
            "String manipulation",
            "File creation",
            "Sorting algorithms"
        ],
        correctAnswer: 2,
        explanation: "File creation requires operating system intervention to allocate disk space, update directory structures, and set up file metadata, making it a system call. The other operations can be performed entirely in user space.",
        category: "System Calls"
    },
    {
        id: 43,
        question: "What is the critical section problem?",
        options: [
            "Running out of memory",
            "Multiple processes accessing shared resources without proper synchronization",
            "Process scheduling conflicts",
            "File system corruption"
        ],
        correctAnswer: 1,
        explanation: "The critical section problem involves ensuring that when multiple processes access shared resources, only one process can be in its critical section (the code segment accessing shared resources) at any time to prevent data corruption.",
        category: "Process Synchronization"
    },
    {
        id: 44,
        question: "What is a mutex?",
        options: [
            "A type of process",
            "A binary semaphore for mutual exclusion",
            "A memory allocation technique",
            "A file locking mechanism"
        ],
        correctAnswer: 1,
        explanation: "A mutex (mutual exclusion) is a synchronization primitive that acts like a binary semaphore (0 or 1) to ensure that only one thread or process can access a shared resource at a time.",
        category: "Process Synchronization"
    },
    {
        id: 45,
        question: "What is thrashing in virtual memory systems?",
        options: [
            "Excessive page faulting that degrades performance",
            "Memory corruption",
            "Process termination",
            "Disk fragmentation"
        ],
        correctAnswer: 0,
        explanation: "Thrashing occurs when a system spends more time swapping pages between memory and disk than executing useful work, typically due to insufficient physical memory relative to the working set sizes of active processes.",
        category: "Performance & Optimization"
    },
    {
        id: 46,
        question: "What is locality of reference?",
        options: [
            "Memory addresses are randomly distributed",
            "Programs tend to access memory locations near recently accessed locations",
            "All processes use the same memory locations",
            "Memory is allocated sequentially"
        ],
        correctAnswer: 1,
        explanation: "Locality of reference includes spatial locality (accessing nearby memory locations) and temporal locality (accessing recently used locations again). This principle is crucial for the effectiveness of caches and virtual memory systems.",
        category: "Performance & Optimization"
    },
    {
        id: 47,
        question: "What is the main challenge in distributed operating systems?",
        options: [
            "Limited processing power",
            "Coordinating processes across multiple machines",
            "Insufficient memory",
            "Slow networks"
        ],
        correctAnswer: 1,
        explanation: "Distributed systems must handle coordination, synchronization, and communication between processes running on different machines connected by networks, dealing with issues like network delays, failures, and partitions.",
        category: "Distributed Systems"
    },
    {
        id: 48,
        question: "What distinguishes real-time operating systems from general-purpose operating systems?",
        options: [
            "Higher processing speed",
            "Guaranteed response times for critical tasks",
            "Better graphics support",
            "More memory capacity"
        ],
        correctAnswer: 1,
        explanation: "Real-time operating systems provide deterministic timing guarantees, ensuring that critical tasks complete within specified deadlines. This is essential for applications like medical devices, automotive systems, and industrial control.",
        category: "Real-time Systems"
    },
    {
        id: 49,
        question: "What is the primary function of a bootloader?",
        options: [
            "To manage memory",
            "To load the operating system kernel into memory",
            "To handle user login",
            "To manage network connections"
        ],
        correctAnswer: 1,
        explanation: "The bootloader is responsible for loading the operating system kernel from storage into memory and transferring control to it. This is one of the first steps in the computer boot process after hardware initialization.",
        category: "Boot Process"
    },
    {
        id: 50,
        question: "What is copy-on-write (COW)?",
        options: [
            "A file backup technique",
            "A memory optimization where pages are copied only when modified",
            "A network protocol",
            "A disk compression method"
        ],
        correctAnswer: 1,
        explanation: "Copy-on-write allows multiple processes to share the same physical memory pages until one process tries to modify a page, at which point a private copy is made. This saves memory and improves fork() performance.",
        category: "Advanced Memory Management"
    },
    {
        id: 51,
        question: "What is the purpose of an inode in UNIX file systems?",
        options: [
            "To store file data",
            "To store file metadata and disk block pointers",
            "To manage user permissions",
            "To handle network connections"
        ],
        correctAnswer: 1,
        explanation: "An inode (index node) contains file metadata such as size, permissions, timestamps, and pointers to the disk blocks containing the file's data. The filename is stored in directory entries that point to inodes.",
        category: "File System Implementation"
    },
    {
        id: 52,
        question: "What is journaling in file systems?",
        options: [
            "A backup technique",
            "Recording file system changes in a log before applying them",
            "A compression method",
            "A user activity monitoring system"
        ],
        correctAnswer: 1,
        explanation: "Journaling file systems write metadata changes to a journal (log) before applying them to the main file system structures. This allows quick recovery after system crashes by replaying or undoing incomplete operations.",
        category: "File System Implementation"
    },
    {
        id: 53,
        question: "What is the principle of least privilege?",
        options: [
            "Users should have maximum access for convenience",
            "Users should have only the minimum access necessary for their tasks",
            "All users should have equal access",
            "Access should be randomly distributed"
        ],
        correctAnswer: 1,
        explanation: "The principle of least privilege states that users and processes should be granted only the minimum level of access or permissions needed to perform their legitimate functions, reducing security risks.",
        category: "Security"
    },
    {
        id: 54,
        question: "What is a buffer overflow attack?",
        options: [
            "Running out of disk space",
            "Exploiting programs that don't check input buffer boundaries",
            "Network congestion",
            "Memory leaks"
        ],
        correctAnswer: 1,
        explanation: "Buffer overflow attacks occur when programs write more data to a buffer than it can hold, potentially overwriting adjacent memory areas. Attackers can exploit this to inject malicious code or alter program execution.",
        category: "Security"
    },
    {
        id: 55,
        question: "What is containerization?",
        options: [
            "A backup storage method",
            "Lightweight virtualization using OS-level isolation",
            "A file compression technique",
            "A network security protocol"
        ],
        correctAnswer: 1,
        explanation: "Containerization provides isolated execution environments that share the same OS kernel but have separate user spaces, file systems, and network interfaces. It's lighter weight than full virtualization while still providing isolation.",
        category: "Modern OS Features"
    },
    {
        id: 56,
        question: "What is the main advantage of microkernel architecture over monolithic kernels?",
        options: [
            "Better performance",
            "Improved modularity and fault isolation",
            "Less memory usage",
            "Faster boot times"
        ],
        correctAnswer: 1,
        explanation: "Microkernels move most OS services to user-space servers, keeping only essential functions (IPC, basic scheduling, memory management) in kernel space. This improves modularity and prevents service failures from crashing the entire system.",
        category: "Modern OS Features"
    },
    {
        id: 57,
        question: "What does the `ps` command show in UNIX systems?",
        options: [
            "Disk space usage",
            "Currently running processes",
            "Network connections",
            "File permissions"
        ],
        correctAnswer: 1,
        explanation: "The `ps` command displays information about currently running processes, including process IDs, CPU usage, memory usage, and command names. Different options provide various levels of detail and filtering.",
        category: "Performance Monitoring"
    },
    {
        id: 58,
        question: "What is the purpose of the `top` command?",
        options: [
            "To display the directory tree",
            "To show real-time system performance and process information",
            "To manage file permissions",
            "To configure network settings"
        ],
        correctAnswer: 1,
        explanation: "The `top` command provides a dynamic, real-time view of system performance, showing CPU usage, memory usage, running processes, and system load averages, updating the display periodically.",
        category: "Performance Monitoring"
    },
    {
        id: 59,
        question: "What is swappiness in Linux?",
        options: [
            "A network configuration parameter",
            "A parameter controlling how aggressively the system swaps memory to disk",
            "A file system type",
            "A process priority setting"
        ],
        correctAnswer: 1,
        explanation: "Swappiness is a Linux kernel parameter (0-100) that controls the tendency to swap memory pages to disk. Lower values make the kernel avoid swapping, while higher values make it more likely to swap pages to free RAM.",
        category: "System Optimization"
    },
    {
        id: 60,
        question: "What is the working set of a process?",
        options: [
            "The CPU registers used by the process",
            "The set of memory pages the process is actively using",
            "The files opened by the process",
            "The child processes created by the process"
        ],
        correctAnswer: 1,
        explanation: "The working set is the collection of memory pages that a process references during a given time interval. Understanding working sets is crucial for memory management decisions and preventing thrashing in virtual memory systems.",
        category: "System Optimization"
    },
    {
        id: 61,
        question: "Which command would you use to view detailed permissions for all files in a directory?",
        options: [
            "chmod",
            "ls -l",
            "cat",
            "ps"
        ],
        correctAnswer: 1,
        explanation: "The `ls -l` command lists files in long format, showing permissions, ownership, size, and modification date for each file.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 62,
        question: "In UNIX, what does the command `chmod 600 myfile` do?",
        options: [
            "Gives everyone full access to myfile",
            "Owner can read/write, others have no access",
            "Owner can only read, others can write",
            "Group can execute, owner cannot"
        ],
        correctAnswer: 1,
        explanation: "6 = read+write for owner, 0 = no permissions for group and others.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 63,
        question: "What is the main purpose of file metadata?",
        options: [
            "Store the file's actual data",
            "Store information about the file (size, permissions, timestamps)",
            "Encrypt the file",
            "Compress the file"
        ],
        correctAnswer: 1,
        explanation: "Metadata describes the file's properties, not its content.",
        category: "File Systems & Management"
    },
    {
        id: 64,
        question: "Which of the following is NOT a valid UNIX file type?",
        options: [
            "Directory",
            "Regular file",
            "Device file",
            "Spreadsheet file"
        ],
        correctAnswer: 3,
        explanation: "UNIX recognizes regular files, directories, device files, and pipes, but not application-specific types like spreadsheets.",
        category: "File Systems & Management"
    },
    {
        id: 65,
        question: "What is the main advantage of dynamic memory allocation over fixed partitioning?",
        options: [
            "Simpler implementation",
            "Reduces internal fragmentation",
            "Increases external fragmentation",
            "Prevents all fragmentation"
        ],
        correctAnswer: 1,
        explanation: "Dynamic allocation matches memory to process needs, reducing wasted space inside partitions.",
        category: "Memory Management"
    },
    {
        id: 66,
        question: "What is a page fault?",
        options: [
            "When a process tries to access a page not in physical memory",
            "When a process divides by zero",
            "When a file cannot be found",
            "When a process is blocked"
        ],
        correctAnswer: 0,
        explanation: "The OS must load the required page from disk into RAM, which can slow down execution.",
        category: "Virtual Memory"
    },
    {
        id: 67,
        question: "Which process state is responsible for waiting for I/O completion?",
        options: [
            "Ready",
            "Running",
            "Blocked",
            "New"
        ],
        correctAnswer: 2,
        explanation: "Blocked processes are waiting for an event, such as I/O, to complete before they can continue.",
        category: "Process Management"
    },
    {
        id: 68,
        question: "What is the main function of the Process Control Block (PCB)?",
        options: [
            "Store the process's executable code",
            "Track the process's state and resources",
            "Manage device drivers",
            "Handle file permissions"
        ],
        correctAnswer: 1,
        explanation: "The PCB contains information like process state, program counter, CPU registers, memory management info, and open files.",
        category: "Process Management"
    },
    {
        id: 69,
        question: "Which scheduling goal is most important for interactive systems?",
        options: [
            "High throughput",
            "Low latency",
            "Fairness",
            "High CPU utilization"
        ],
        correctAnswer: 1,
        explanation: "Interactive systems prioritize quick response to user actions, which requires low latency.",
        category: "CPU Scheduling"
    },
    {
        id: 70,
        question: "What is the effect of setting a very high swappiness value in Linux?",
        options: [
            "The system will avoid swapping",
            "The system will swap aggressively",
            "The system will crash",
            "The system will ignore swap space"
        ],
        correctAnswer: 1,
        explanation: "High swappiness means the kernel will move processes to swap space more readily to free up RAM.",
        category: "System Optimization"
    },
    {
        id: 71,
        question: "Which of the following is a scenario where a race condition can occur?",
        options: [
            "Two processes reading the same file",
            "Two processes writing to the same variable without synchronization",
            "One process waiting for I/O",
            "A process running in user mode"
        ],
        correctAnswer: 1,
        explanation: "Without proper synchronization, the final value depends on the order of execution, leading to unpredictable results.",
        category: "Inter-Process Communication"
    },
    {
        id: 72,
        question: "What is the main role of a semaphore in process synchronization?",
        options: [
            "To allocate memory",
            "To control access to shared resources",
            "To schedule processes",
            "To manage device drivers"
        ],
        correctAnswer: 1,
        explanation: "Semaphores are used to implement mutual exclusion and coordinate process execution.",
        category: "Process Synchronization"
    },
    {
        id: 73,
        question: "Which IPC mechanism is best for high-speed data sharing between processes?",
        options: [
            "Pipes",
            "Message queues",
            "Shared memory",
            "Signals"
        ],
        correctAnswer: 2,
        explanation: "Shared memory allows processes to access the same memory region directly, making it the fastest IPC method.",
        category: "IPC Mechanisms"
    },
    {
        id: 74,
        question: "What does the signal SIGKILL do?",
        options: [
            "Requests a process to terminate gracefully",
            "Forces a process to terminate immediately",
            "Ignores the process",
            "Suspends the process"
        ],
        correctAnswer: 1,
        explanation: "SIGKILL cannot be caught or ignored and guarantees process termination.",
        category: "Signals"
    },
    {
        id: 75,
        question: "Which of the following is a necessary condition for deadlock?",
        options: [
            "Preemption",
            "Circular wait",
            "Shared memory",
            "High CPU utilization"
        ],
        correctAnswer: 1,
        explanation: "Deadlock requires mutual exclusion, hold and wait, no preemption, and circular wait.",
        category: "Synchronization & Deadlocks"
    },
    {
        id: 76,
        question: "What is the main difference between block and character devices?",
        options: [
            "Block devices transfer data in fixed-size blocks; character devices transfer data as streams",
            "Block devices are slower",
            "Character devices are only for input",
            "Block devices cannot be used for storage"
        ],
        correctAnswer: 0,
        explanation: "Disks are block devices; keyboards and mice are character devices.",
        category: "I/O & Device Management"
    },
    {
        id: 77,
        question: "What is the purpose of a device driver?",
        options: [
            "To provide a uniform interface between hardware and software",
            "To increase device speed",
            "To encrypt device data",
            "To manage user permissions"
        ],
        correctAnswer: 0,
        explanation: "Device drivers translate generic OS requests into device-specific commands.",
        category: "I/O & Device Management"
    },
    {
        id: 78,
        question: "Which of the following is a system call?",
        options: [
            "printf()",
            "open()",
            "sqrt()",
            "strcpy()"
        ],
        correctAnswer: 1,
        explanation: "open() is a system call for opening files; printf(), sqrt(), and strcpy() are library functions.",
        category: "System Calls"
    },
    {
        id: 79,
        question: "Why are system calls more expensive than library functions?",
        options: [
            "They require a mode switch from user to kernel mode",
            "They use more memory",
            "They are written in assembly language",
            "They are slower to compile"
        ],
        correctAnswer: 0,
        explanation: "System calls involve saving/restoring registers, changing memory mappings, and security checks.",
        category: "System Calls"
    },
    {
        id: 80,
        question: "What is thrashing?",
        options: [
            "When the system spends most of its time swapping pages in and out of memory",
            "When a process is blocked",
            "When the CPU overheats",
            "When a device driver fails"
        ],
        correctAnswer: 0,
        explanation: "Thrashing occurs when there is insufficient physical memory and the working set of processes cannot fit in RAM.",
        category: "Performance & Optimization"
    },
    {
        id: 81,
        question: "What is the principle of least privilege?",
        options: [
            "Give users maximum access",
            "Give users only the access they need",
            "Allow all users to be administrators",
            "Deny all access by default"
        ],
        correctAnswer: 1,
        explanation: "This principle reduces the risk of accidental or malicious damage.",
        category: "Security"
    },
    {
        id: 82,
        question: "What is a buffer overflow?",
        options: [
            "When a process uses too much CPU",
            "When data exceeds the storage capacity of a buffer and overwrites adjacent memory",
            "When a device driver fails",
            "When a process is blocked"
        ],
        correctAnswer: 1,
        explanation: "Buffer overflows can lead to security vulnerabilities and program crashes.",
        category: "Security"
    },
    {
        id: 83,
        question: "Which kernel architecture provides better fault isolation?",
        options: [
            "Monolithic kernel",
            "Microkernel",
            "Hybrid kernel",
            "Exokernel"
        ],
        correctAnswer: 1,
        explanation: "Microkernels run most services in user space, so faults in those services do not crash the whole system.",
        category: "Modern OS Features"
    },
    {
        id: 84,
        question: "What is the main advantage of containerization over traditional virtualization?",
        options: [
            "Each container has its own kernel",
            "Containers are more lightweight and share the host OS kernel",
            "Containers require more resources",
            "Containers are slower to start"
        ],
        correctAnswer: 1,
        explanation: "Containers use OS-level virtualization, making them faster and more resource-efficient than full VMs.",
        category: "Modern OS Features"
    },
    {
        id: 85,
        question: "What is the first step in the boot process of a modern computer?",
        options: [
            "Kernel initialization",
            "BIOS/UEFI hardware initialization",
            "Bootloader loads the kernel",
            "User login"
        ],
        correctAnswer: 1,
        explanation: "The BIOS/UEFI initializes hardware and then loads the bootloader.",
        category: "Boot Process"
    },
    {
        id: 86,
        question: "Which of the following is a quick way to check currently running processes in UNIX?",
        options: [
            "ls",
            "ps",
            "chmod",
            "cat"
        ],
        correctAnswer: 1,
        explanation: "The `ps` command lists currently running processes and their details.",
        category: "Performance Monitoring"
    },
    {
        id: 87,
        question: "What is the main function of the MMU (Memory Management Unit)?",
        options: [
            "Encrypt memory",
            "Translate logical addresses to physical addresses",
            "Manage device drivers",
            "Handle file permissions"
        ],
        correctAnswer: 1,
        explanation: "The MMU enables virtual memory and memory protection by mapping logical to physical addresses.",
        category: "Memory Management"
    },
    {
        id: 88,
        question: "What is a context switch?",
        options: [
            "Changing from one device driver to another",
            "Saving the state of one process and loading the state of another",
            "Switching from user mode to kernel mode",
            "Changing file permissions"
        ],
        correctAnswer: 1,
        explanation: "Context switching allows multitasking by letting the CPU switch between processes.",
        category: "Process Management"
    },
    {
        id: 89,
        question: "Which of the following is NOT a benefit of virtual memory?",
        options: [
            "Ability to run programs larger than physical RAM",
            "Simplified programming",
            "Increased CPU speed",
            "Memory protection"
        ],
        correctAnswer: 2,
        explanation: "Virtual memory does not make the CPU faster; it enables larger programs and better memory management.",
        category: "Virtual Memory"
    },
    {
        id: 90,
        question: "What is the main purpose of the fork() system call in UNIX?",
        options: [
            "To terminate a process",
            "To create a new process",
            "To allocate memory",
            "To open a file"
        ],
        correctAnswer: 1,
        explanation: "fork() creates a child process that is a copy of the parent.",
        category: "Process Management"
    },
    {
        id: 91,
        question: "Which of the following is a real-time system requirement?",
        options: [
            "High throughput",
            "Deterministic response time",
            "Large memory capacity",
            "User-friendly interface"
        ],
        correctAnswer: 1,
        explanation: "Real-time systems must guarantee that tasks complete within strict timing constraints.",
        category: "Real-time Systems"
    },
    {
        id: 92,
        question: "What is the main difference between authentication and authorization?",
        options: [
            "Authentication is about who you are; authorization is about what you can do",
            "Authorization is about who you are; authentication is about what you can do",
            "Both are the same",
            "Neither is important in OS"
        ],
        correctAnswer: 0,
        explanation: "Authentication verifies identity; authorization determines access rights.",
        category: "Security"
    },
    {
        id: 93,
        question: "What is the function of the exec() system call?",
        options: [
            "To create a new process",
            "To replace the current process image with a new program",
            "To terminate a process",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "exec() loads a new program into the current process, replacing its code and data.",
        category: "System Calls"
    },
    {
        id: 94,
        question: "Which of the following is a benefit of using pipes for IPC?",
        options: [
            "Allows bidirectional communication by default",
            "Provides a simple way to connect the output of one process to the input of another",
            "Requires shared memory",
            "Is only available in Windows"
        ],
        correctAnswer: 1,
        explanation: "Pipes are unidirectional and are commonly used to chain commands in UNIX.",
        category: "IPC Mechanisms"
    },
    {
        id: 95,
        question: "What is the main purpose of the init process in UNIX?",
        options: [
            "To manage device drivers",
            "To start all other user-space processes after the kernel boots",
            "To handle file permissions",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "init (or its modern equivalents) is the first user-space process and manages system startup.",
        category: "Boot Process"
    },
    {
        id: 96,
        question: "What is the main difference between spatial and temporal locality?",
        options: [
            "Spatial locality is about accessing nearby locations; temporal locality is about accessing recently used locations",
            "Spatial locality is about time; temporal locality is about space",
            "Both refer to the same concept",
            "Neither is important in OS"
        ],
        correctAnswer: 0,
        explanation: "Both are principles that make caching and virtual memory effective.",
        category: "Performance & Optimization"
    },
    {
        id: 97,
        question: "What is the main advantage of using a microkernel?",
        options: [
            "All services run in kernel space",
            "Faults in user-space services do not crash the whole system",
            "It is slower than monolithic kernels",
            "It uses more memory"
        ],
        correctAnswer: 1,
        explanation: "Microkernels improve fault isolation by running most services in user space.",
        category: "Modern OS Features"
    },
    {
        id: 98,
        question: "What is the main function of the bootloader?",
        options: [
            "To initialize hardware",
            "To load the operating system kernel into memory",
            "To manage user logins",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "The bootloader loads the kernel after hardware initialization.",
        category: "Boot Process"
    },
    {
        id: 99,
        question: "What is the main purpose of stack canaries?",
        options: [
            "To speed up process creation",
            "To detect buffer overflows",
            "To manage device drivers",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "Stack canaries are special values placed on the stack to detect overwrites caused by buffer overflows.",
        category: "Security"
    },
    {
        id: 100,
        question: "What is the main benefit of using address space randomization?",
        options: [
            "To make programs run faster",
            "To make it harder for attackers to predict memory locations",
            "To increase memory usage",
            "To simplify programming"
        ],
        correctAnswer: 1,
        explanation: "Address space randomization is a security technique that makes exploits more difficult by randomizing memory layout.",
        category: "Security"
    }
];

// Quiz state variables
let currentQuestion = 0;
let currentQuestionIndex = 0;
let userAnswers = [];
let score = 0;
let quizStarted = false;
let currentMode = 'quiz'; // 'quiz' or 'notes'

// DOM Elements
const quizContainer = document.querySelector('.quiz-container');
const notesSection = document.querySelector('.notes-section');
const questionSection = document.querySelector('.question-section');
const questionText = document.getElementById('question-text');
const optionsSection = document.querySelector('.options-section');
const explanationSection = document.querySelector('.explanation-section');
const nextBtn = document.getElementById('next-btn');
const prevBtn = document.getElementById('prev-btn');
const submitBtn = document.getElementById('submit-btn');
const showAnswerBtn = document.getElementById('show-answer-btn');
const resultsSection = document.querySelector('.results-section');
const restartBtn = document.getElementById('restart-btn');
const reviewBtn = document.getElementById('review-btn');
const progressBar = document.querySelector('.progress');
const questionCounter = document.querySelector('.question-counter');

// Navigation buttons
const quizBtn = document.getElementById('quiz-btn');
const notesBtn = document.getElementById('notes-btn');
const mockTcaBtn = document.getElementById('mock-tca-btn');

// Enhanced Quiz State Management
let enhancedQuizState = {
    currentQuestion: 0,
    userAnswers: [],
    showingResults: false,
    bookmarkedQuestions: new Set(),
    categoryPerformance: {},
    timeStarted: null,
    timeCompleted: null,
    reviewMode: false
};

// Enhanced Quiz Categories for detailed analysis
const questionCategoriesMapping = {
    'Access Rights & File Permissions': [],
    'File Systems & Management': [],
    'File System Internals': [],
    'Memory Management': [],
    'Virtual Memory & Paging': [],
    'Process Management': [],
    'CPU Scheduling': [],
    'Inter-Process Communication': [],
    'Synchronization & Deadlocks': [],
    'System Calls & APIs': [],
    'I/O & Device Management': [],
    'Security & Protection': []
};

// Initialize category mapping for enhanced quiz
function initializeEnhancedCategoryMapping() {
    questions.forEach((question, index) => {
        if (questionCategoriesMapping[question.category]) {
            questionCategoriesMapping[question.category].push(index);
        }
    });
}

// Enhanced quiz initialization
function initializeEnhancedQuizFeatures() {
    initializeEnhancedCategoryMapping();
    
    // Start quiz button event
    const startQuizBtn = document.getElementById('start-extra-quiz');
    if (startQuizBtn) {
        startQuizBtn.addEventListener('click', startEnhancedQuiz);
    }
    
    // Bookmark button event
    const bookmarkBtn = document.getElementById('bookmark-btn');
    if (bookmarkBtn) {
        bookmarkBtn.addEventListener('click', toggleQuestionBookmark);
    }
    
    // Study notes button from results
    const studyNotesBtn = document.getElementById('study-notes-btn');
    if (studyNotesBtn) {
        studyNotesBtn.addEventListener('click', () => {
            showNotesMode();
        });
    }
    
    // Mock TCA button from results
    const mockTcaFromResultsBtn = document.getElementById('mock-tca-btn');
    if (mockTcaFromResultsBtn) {
        mockTcaFromResultsBtn.addEventListener('click', () => {
            showMockTcaMode();
        });
    }
}

function startEnhancedQuiz() {
    const introSection = document.getElementById('quiz-intro');
    const quizContainer = document.getElementById('quiz-container');
    
    if (introSection && quizContainer) {
        introSection.style.display = 'none';
        quizContainer.style.display = 'block';
        
        // Reset quiz state
        enhancedQuizState = {
            currentQuestion: 0,
            userAnswers: [],
            showingResults: false,
            bookmarkedQuestions: new Set(),
            categoryPerformance: {},
            timeStarted: Date.now(),
            timeCompleted: null,
            reviewMode: false
        };
        
        // Initialize answers array
        enhancedQuizState.userAnswers = new Array(questions.length).fill(null);
        
        // Start the quiz
        currentQuestion = 0;
        displayQuestion();
        updateEnhancedProgressBar();
    }
}

function updateEnhancedProgressBar() {
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    
    if (progressFill && progressText) {
        const progress = ((currentQuestion + 1) / questions.length) * 100;
        progressFill.style.width = `${progress}%`;
        progressText.textContent = `Question ${currentQuestion + 1} of ${questions.length}`;
    }
}

function displayEnhancedQuestion() {
    const question = questions[currentQuestion];
    
    // Update question content
    document.getElementById('question-text').textContent = question.question;
    document.getElementById('option-a').textContent = question.options[0];
    document.getElementById('option-b').textContent = question.options[1];
    document.getElementById('option-c').textContent = question.options[2];
    document.getElementById('option-d').textContent = question.options[3];
    
    // Update category display
    const categoryElement = document.getElementById('quiz-category');
    if (categoryElement && question.category) {
        categoryElement.textContent = `📂 ${question.category}`;
    }
    
    // Update bookmark button
    const bookmarkBtn = document.getElementById('bookmark-btn');
    if (bookmarkBtn) {
        if (enhancedQuizState.bookmarkedQuestions.has(currentQuestion)) {
            bookmarkBtn.innerHTML = '🔖 Bookmarked';
            bookmarkBtn.classList.add('bookmarked');
        } else {
            bookmarkBtn.innerHTML = '🔖 Bookmark';
            bookmarkBtn.classList.remove('bookmarked');
        }
    }
    
    updateEnhancedProgressBar();
}

function toggleQuestionBookmark() {
    if (enhancedQuizState.bookmarkedQuestions.has(currentQuestion)) {
        enhancedQuizState.bookmarkedQuestions.delete(currentQuestion);
    } else {
        enhancedQuizState.bookmarkedQuestions.add(currentQuestion);
    }
    displayEnhancedQuestion();
}

function calculateEnhancedCategoryPerformance() {
    const categoryStats = {};
    
    // Initialize category stats
    Object.keys(questionCategoriesMapping).forEach(category => {
        categoryStats[category] = {
            total: questionCategoriesMapping[category].length,
            correct: 0,
            incorrect: 0,
            percentage: 0
        };
    });
    
    // Calculate performance for each category
    questions.forEach((question, index) => {
        const category = question.category;
        const userAnswer = enhancedQuizState.userAnswers[index];
        const correctAnswer = question.correctAnswer;
        
        if (categoryStats[category]) {
            if (userAnswer === correctAnswer) {
                categoryStats[category].correct++;
            } else if (userAnswer !== null) {
                categoryStats[category].incorrect++;
            }
        }
    });
    
    // Calculate percentages
    Object.keys(categoryStats).forEach(category => {
        const stats = categoryStats[category];
        if (stats.total > 0) {
            stats.percentage = Math.round((stats.correct / stats.total) * 100);
        }
    });
    
    return categoryStats;
}

function displayEnhancedQuizResults() {
    enhancedQuizState.timeCompleted = Date.now();
    const timeTaken = enhancedQuizState.timeCompleted - enhancedQuizState.timeStarted;
    
    // Calculate basic stats
    let correctCount = 0;
    let incorrectCount = 0;
    
    enhancedQuizState.userAnswers.forEach((answer, index) => {
        if (answer === questions[index].correctAnswer) {
            correctCount++;
        } else if (answer !== null) {
            incorrectCount++;
        }
    });
    
    const percentage = Math.round((correctCount / questions.length) * 100);
    
    // Update score display
    document.getElementById('final-score').textContent = correctCount;
    document.getElementById('percentage').textContent = percentage;
    document.getElementById('correct-count').textContent = correctCount;
    document.getElementById('incorrect-count').textContent = incorrectCount;
    
    // Calculate category performance
    const categoryStats = calculateEnhancedCategoryPerformance();
    enhancedQuizState.categoryPerformance = categoryStats;
    
    // Display category breakdown
    displayEnhancedCategoryBreakdown(categoryStats);
    
    // Calculate strong/weak areas
    const strongAreas = Object.keys(categoryStats).filter(cat => categoryStats[cat].percentage >= 80).length;
    const improvementAreas = Object.keys(categoryStats).filter(cat => categoryStats[cat].percentage < 60 && categoryStats[cat].total > 0).length;
    
    document.getElementById('strong-areas').textContent = strongAreas;
    document.getElementById('improvement-areas').textContent = improvementAreas;
    
    // Update grade
    const gradeElement = document.getElementById('grade');
    if (percentage >= 90) {
        gradeElement.innerHTML = '🏆 Outstanding (A+)';
        gradeElement.className = 'grade excellent';
    } else if (percentage >= 80) {
        gradeElement.innerHTML = '🌟 Excellent (A)';
        gradeElement.className = 'grade excellent';
    } else if (percentage >= 70) {
        gradeElement.innerHTML = '👍 Good (B)';
        gradeElement.className = 'grade good';
    } else if (percentage >= 60) {
        gradeElement.innerHTML = '👌 Fair (C)';
        gradeElement.className = 'grade fair';
    } else if (percentage >= 50) {
        gradeElement.innerHTML = '📚 Pass (D)';
        gradeElement.className = 'grade pass';
    } else {
        gradeElement.innerHTML = '💪 Keep Studying (F)';
        gradeElement.className = 'grade fail';
    }
}

function displayEnhancedCategoryBreakdown(categoryStats) {
    const categoryContainer = document.getElementById('category-performance');
    if (!categoryContainer) return;
    
    categoryContainer.innerHTML = '';
    
    Object.keys(categoryStats).forEach(category => {
        const stats = categoryStats[category];
        if (stats.total === 0) return;
        
        const categoryItem = document.createElement('div');
        categoryItem.className = 'category-item';
        
        const performanceClass = stats.percentage >= 80 ? 'excellent' : 
                               stats.percentage >= 70 ? 'good' : 
                               stats.percentage >= 60 ? 'fair' : 'needs-improvement';
        
        categoryItem.innerHTML = `
            <div class="category-name">${category}</div>
            <div class="category-stats">
                <div class="category-score ${performanceClass}">${stats.correct}/${stats.total}</div>
                <div class="category-percentage">${stats.percentage}%</div>
            </div>
            <div class="category-bar">
                <div class="category-fill ${performanceClass}" style="width: ${stats.percentage}%"></div>
            </div>
        `;
        
        categoryContainer.appendChild(categoryItem);
    });
}

// Enhanced explanation display
function showEnhancedQuizExplanation() {
    const question = questions[currentQuestion];
    const explanationSection = document.getElementById('explanation-section');
    const explanationText = document.getElementById('explanation-text');
    const explanationCategory = document.getElementById('explanation-category');
    
    if (explanationSection && explanationText) {
        explanationText.textContent = question.explanation;
        
        if (explanationCategory && question.category) {
            explanationCategory.textContent = `Category: ${question.category}`;
        }
        
        // Add key concepts if available
        const keyConceptsSection = document.getElementById('key-concepts');
        const keyConceptsList = document.getElementById('key-concepts-list');
        
        if (question.keyPoints && keyConceptsSection && keyConceptsList) {
            keyConceptsList.innerHTML = '';
            question.keyPoints.forEach(point => {
                const li = document.createElement('li');
                li.textContent = point;
                keyConceptsList.appendChild(li);
            });
            keyConceptsSection.style.display = 'block';
        }
        
        explanationSection.style.display = 'block';
    }
}

// Enhanced TCA explanation system
function enhanceTCAQuestions() {
    // Add detailed explanations for TCA questions with better formatting
    const tcaQuestions = document.querySelectorAll('#mock-tca-section .mcq-question');
    
    tcaQuestions.forEach((questionElement, index) => {
        const answerDiv = questionElement.querySelector('.mcq-answer');
        if (answerDiv) {
            // Enhance the explanation formatting
            const currentExplanation = answerDiv.innerHTML;
            
            // Add study tips and memory aids where appropriate
            let enhancedExplanation = currentExplanation;
            
            // Add category-specific tips based on question content
            if (questionElement.textContent.includes('Super Block')) {
                enhancedExplanation += `<br><br><strong>💡 Study Tip:</strong> Remember "Super Block = Super Important metadata" - it's like the table of contents for the entire filesystem.`;
            } else if (questionElement.textContent.includes('Priority scheduling')) {
                enhancedExplanation += `<br><br><strong>💡 Study Tip:</strong> Think of priority scheduling like a hospital emergency room - high priority patients (processes) get treated first, regardless of arrival time.`;
            } else if (questionElement.textContent.includes('fork()')) {
                enhancedExplanation += `<br><br><strong>💡 Study Tip:</strong> fork() creates a copy - child gets 0, parent gets child's PID, error returns -1. Remember: "0 for child, positive for parent, negative for problems."`;
            } else if (questionElement.textContent.includes('chmod')) {
                enhancedExplanation += `<br><br><strong>💡 Study Tip:</strong> UNIX permissions: r=4, w=2, x=1. Add them up: rwx=7, r-x=5, r--=4. Think "Read(4) Write(2) eXecute(1)".`;
            }
            
            answerDiv.innerHTML = enhancedExplanation;
        }
    });
}

// TCA Quiz State Management
let tcaQuizState = {
    isExamMode: false,
    startTime: null,
    endTime: null,
    timeLimit: 120 * 60 * 1000, // 2 hours in milliseconds
    timer: null,
    answers: {},
    currentScore: 0,
    isSubmitted: false
};

// Toggle Answer Function for Mock TCA
function toggleAnswer(buttonElement) {
    const questionDiv = buttonElement.closest('.mcq-question');
    const answerDiv = questionDiv.querySelector('.mcq-answer');
    const feedbackDiv = questionDiv.querySelector('.review-feedback');
    
    if (answerDiv) {
        if (answerDiv.style.display === 'none' || answerDiv.style.display === '') {
            answerDiv.style.display = 'block';
            buttonElement.textContent = 'Hide Answer';
            
            // If in exam mode, provide feedback
            if (tcaQuizState.isExamMode && !tcaQuizState.isSubmitted) {
                showAnswerFeedback(questionDiv, answerDiv, feedbackDiv);
            }
        } else {
            answerDiv.style.display = 'none';
            buttonElement.textContent = 'Show Answer';
            if (feedbackDiv) {
                feedbackDiv.style.display = 'none';
            }
        }
    }
}

// Show answer feedback during exam
function showAnswerFeedback(questionDiv, answerDiv, feedbackDiv) {
    const questionNumber = questionDiv.getAttribute('data-question');
    const correctAnswer = answerDiv.getAttribute('data-correct');
    const selectedInput = questionDiv.querySelector('input[type="radio"]:checked');
    
    if (feedbackDiv) {
        if (selectedInput) {
            const userAnswer = selectedInput.value;
            if (userAnswer === correctAnswer) {
                feedbackDiv.innerHTML = '<div class="feedback correct">✅ Correct! Well done.</div>';
                feedbackDiv.className = 'review-feedback correct';
            } else {
                feedbackDiv.innerHTML = `<div class="feedback incorrect">❌ Incorrect. Your answer: ${userAnswer}, Correct answer: ${correctAnswer}</div>`;
                feedbackDiv.className = 'review-feedback incorrect';
            }
        } else {
            feedbackDiv.innerHTML = '<div class="feedback unanswered">⚠️ You haven\'t answered this question yet.</div>';
            feedbackDiv.className = 'review-feedback unanswered';
        }
        feedbackDiv.style.display = 'block';
    }
}

// Start Exam Mode
function startExamMode() {
    tcaQuizState.isExamMode = true;
    tcaQuizState.startTime = new Date();
    tcaQuizState.answers = {};
    tcaQuizState.isSubmitted = false;
    
    // Show exam controls
    document.getElementById('start-exam-mode').style.display = 'none';
    document.getElementById('submit-exam').style.display = 'inline-block';
    document.getElementById('exam-info').style.display = 'block';
    document.getElementById('show-all-answers').style.display = 'none';
    
    // Hide all answer sections
    document.querySelectorAll('#mock-tca-section .mcq-answer').forEach(answer => {
        answer.style.display = 'none';
    });
    
    // Reset reveal buttons
    document.querySelectorAll('#mock-tca-section .reveal-answer').forEach(button => {
        button.textContent = 'Show Answer';
    });
    
    // Clear all selections
    document.querySelectorAll('#mock-tca-section input[type="radio"]').forEach(input => {
        input.checked = false;
    });
    
    // Reset question status indicators
    document.querySelectorAll('#mock-tca-section .question-status').forEach(status => {
        status.setAttribute('data-status', 'unanswered');
        status.textContent = '❓';
    });
    
    // Start timer
    startExamTimer();
    updateAnsweredCount();
    
    // Add event listeners for question changes
    setupTCAEventListeners();
    
    alert('🎯 Exam mode started! You have 2 hours to complete 40 questions. Good luck!');
}

// Start exam timer
function startExamTimer() {
    const timerDisplay = document.getElementById('timer-display');
    let timeRemaining = tcaQuizState.timeLimit;
    
    tcaQuizState.timer = setInterval(() => {
        timeRemaining -= 1000;
        
        if (timeRemaining <= 0) {
            clearInterval(tcaQuizState.timer);
            submitExam(true); // Auto-submit when time runs out
            return;
        }
        
        const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
        const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
        
        timerDisplay.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Warning when 10 minutes left
        if (timeRemaining <= 10 * 60 * 1000 && timeRemaining > 9 * 60 * 1000) {
            alert('⚠️ Warning: Only 10 minutes remaining!');
        }
    }, 1000);
}

// Setup TCA event listeners
function setupTCAEventListeners() {
    // Listen for radio button changes
    document.querySelectorAll('#mock-tca-section input[type="radio"]').forEach(input => {
        input.addEventListener('change', function() {
            const questionDiv = this.closest('.mcq-question');
            const questionNumber = questionDiv.getAttribute('data-question');
            const statusIndicator = questionDiv.querySelector('.question-status');
            
            // Store answer
            tcaQuizState.answers[questionNumber] = this.value;
            
            // Update status indicator
            statusIndicator.setAttribute('data-status', 'answered');
            statusIndicator.textContent = '✅';
            
            // Update answered count
            updateAnsweredCount();
        });
    });
}

// Update answered count display
function updateAnsweredCount() {
    const answeredCount = Object.keys(tcaQuizState.answers).length;
    document.getElementById('answered-count').textContent = answeredCount;
}

// Submit exam
function submitExam(isAutoSubmit = false) {
    if (!isAutoSubmit) {
        const answeredCount = Object.keys(tcaQuizState.answers).length;
        if (answeredCount < 40) {
            const proceed = confirm(`You have only answered ${answeredCount} out of 40 questions. Do you want to submit anyway?`);
            if (!proceed) return;
        }
    }
    
    tcaQuizState.endTime = new Date();
    tcaQuizState.isSubmitted = true;
    
    // Stop timer
    if (tcaQuizState.timer) {
        clearInterval(tcaQuizState.timer);
    }
    
    // Calculate score
    calculateTCAScore();
    
    // Update UI
    document.getElementById('submit-exam').style.display = 'none';
    document.getElementById('review-exam').style.display = 'inline-block';
    document.getElementById('retake-exam').style.display = 'inline-block';
    document.getElementById('show-all-answers').style.display = 'inline-block';
    document.getElementById('tca-score').style.display = 'block';
    
    alert(isAutoSubmit ? '⏰ Time\'s up! Exam submitted automatically.' : '📝 Exam submitted successfully!');
}

// Calculate TCA score
function calculateTCAScore() {
    let correctCount = 0;
    let incorrectCount = 0;
    let unansweredCount = 0;
    
    // Get all questions
    const totalQuestions = 40;
    
    for (let i = 1; i <= totalQuestions; i++) {
        const questionDiv = document.querySelector(`#mock-tca-section .mcq-question[data-question="${i}"]`);
        if (questionDiv) {
            const answerDiv = questionDiv.querySelector('.mcq-answer');
            const correctAnswer = answerDiv ? answerDiv.getAttribute('data-correct') : null;
            const userAnswer = tcaQuizState.answers[i];
            
            if (!userAnswer) {
                unansweredCount++;
            } else if (userAnswer === correctAnswer) {
                correctCount++;
            } else {
                incorrectCount++;
            }
        }
    }
    
    tcaQuizState.currentScore = correctCount;
    const percentage = Math.round((correctCount / totalQuestions) * 100);
    
    // Update score display
    document.getElementById('score-value').textContent = correctCount;
    document.getElementById('score-percentage').textContent = `${percentage}%`;
    document.getElementById('correct-count').textContent = correctCount;
    document.getElementById('incorrect-count').textContent = incorrectCount;
    document.getElementById('unanswered-count').textContent = unansweredCount;
    
    // Calculate time taken
    const timeTaken = tcaQuizState.endTime - tcaQuizState.startTime;
    const hours = Math.floor(timeTaken / (1000 * 60 * 60));
    const minutes = Math.floor((timeTaken % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeTaken % (1000 * 60)) / 1000);
    document.getElementById('time-taken').textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    // Update grade indicator
    const gradeIndicator = document.getElementById('grade-indicator');
    if (percentage >= 80) {
        gradeIndicator.innerHTML = '<div class="grade excellent">Grade: A (Excellent)</div>';
    } else if (percentage >= 70) {
        gradeIndicator.innerHTML = '<div class="grade good">Grade: B (Good)</div>';
    } else if (percentage >= 60) {
        gradeIndicator.innerHTML = '<div class="grade fair">Grade: C (Fair)</div>';
    } else if (percentage >= 50) {
        gradeIndicator.innerHTML = '<div class="grade pass">Grade: D (Pass)</div>';
    } else {
        gradeIndicator.innerHTML = '<div class="grade fail">Grade: F (Needs Improvement)</div>';
    }
}

// Review exam results
function reviewExam() {
    // Show all answers and feedback
    document.querySelectorAll('#mock-tca-section .mcq-question').forEach(questionDiv => {
        const answerDiv = questionDiv.querySelector('.mcq-answer');
        const feedbackDiv = questionDiv.querySelector('.review-feedback');
        const revealButton = questionDiv.querySelector('.reveal-answer');
        
        if (answerDiv && revealButton) {
            answerDiv.style.display = 'block';
            revealButton.textContent = 'Hide Answer';
            showAnswerFeedback(questionDiv, answerDiv, feedbackDiv);
        }
    });
}

// Retake exam
function retakeExam() {
    const proceed = confirm('🔄 Are you sure you want to retake the exam? This will reset all your answers.');
    if (proceed) {
        resetTCAQuiz();
        startExamMode();
    }
}

// Show all answers (practice mode)
function showAllAnswers() {
    document.querySelectorAll('#mock-tca-section .mcq-answer').forEach(answer => {
        answer.style.display = 'block';
    });
    
    document.querySelectorAll('#mock-tca-section .reveal-answer').forEach(button => {
        button.textContent = 'Hide Answer';
    });
}

// Reset TCA quiz
function resetTCAQuiz() {
    // Reset state
    tcaQuizState.isExamMode = false;
    tcaQuizState.startTime = null;
    tcaQuizState.endTime = null;
    tcaQuizState.answers = {};
    tcaQuizState.currentScore = 0;
    tcaQuizState.isSubmitted = false;
    
    if (tcaQuizState.timer) {
        clearInterval(tcaQuizState.timer);
    }
    
    // Reset UI
    document.getElementById('start-exam-mode').style.display = 'inline-block';
    document.getElementById('submit-exam').style.display = 'none';
    document.getElementById('review-exam').style.display = 'none';
    document.getElementById('retake-exam').style.display = 'none';
    document.getElementById('show-all-answers').style.display = 'none';
    document.getElementById('exam-info').style.display = 'none';
    document.getElementById('tca-score').style.display = 'none';
    document.getElementById('timer-display').textContent = '02:00:00';
    document.getElementById('answered-count').textContent = '0';
    
    // Hide all answers
    document.querySelectorAll('#mock-tca-section .mcq-answer').forEach(answer => {
        answer.style.display = 'none';
    });
    
    // Reset reveal buttons
    document.querySelectorAll('#mock-tca-section .reveal-answer').forEach(button => {
        button.textContent = 'Show Answer';
    });
    
    // Clear selections
    document.querySelectorAll('#mock-tca-section input[type="radio"]').forEach(input => {
        input.checked = false;
    });
    
    // Reset question status
    document.querySelectorAll('#mock-tca-section .question-status').forEach(status => {
        status.setAttribute('data-status', 'unanswered');
        status.textContent = '❓';
    });
    
    // Hide feedback
    document.querySelectorAll('#mock-tca-section .review-feedback').forEach(feedback => {
        feedback.style.display = 'none';
    });
}

// Main initialization function
function initializeQuiz() {
    // Set initial values
    currentQuestion = 0;
    userAnswers = new Array(questions.length).fill(null);
    score = 0;
    quizStarted = false;
    
    // Setup event listeners
    setupEventListeners();
    
    // Initialize first question if in quiz mode
    if (currentMode === 'quiz') {
        displayQuestion();
    }
    
    console.log('Quiz initialized with', questions.length, 'questions');
}

// Initialize everything when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing quiz...');
    
    // Initialize the quiz
    initializeQuiz();
    
    // Initialize enhanced features
    initializeEnhancedQuizFeatures();
    enhanceTCAQuestions();
    
    // Show quiz mode by default
    showQuizMode();
});

// Core Quiz Functions
function displayQuestion() {
    if (currentQuestion >= questions.length || currentQuestion < 0) return;
    
    const question = questions[currentQuestion];
    
    // Update question content
    document.getElementById('question-text').textContent = question.question;
    document.getElementById('option-a').textContent = question.options[0];
    document.getElementById('option-b').textContent = question.options[1];
    document.getElementById('option-c').textContent = question.options[2];
    document.getElementById('option-d').textContent = question.options[3];
    
    // Clear previous selections
    const options = document.querySelectorAll('.option');
    options.forEach(option => {
        option.classList.remove('selected', 'correct', 'incorrect');
    });
    
    // Show current selection if any
    if (userAnswers[currentQuestion] !== undefined) {
        const selectedOption = document.querySelector(`[data-option="${userAnswers[currentQuestion]}"]`);
        if (selectedOption) {
            selectedOption.classList.add('selected');
        }
    }
    
    // Update navigation buttons
    updateNavigationButtons();
    
    // Hide explanation
    document.getElementById('explanation-section').style.display = 'none';
    
    // Update progress
    updateProgress();
}

function updateNavigationButtons() {
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-btn');
    
    if (prevBtn) prevBtn.disabled = currentQuestion === 0;
    
    if (currentQuestion === questions.length - 1) {
        if (nextBtn) nextBtn.style.display = 'none';
        if (submitBtn) submitBtn.style.display = 'inline-block';
    } else {
        if (nextBtn) nextBtn.style.display = 'inline-block';
        if (submitBtn) submitBtn.style.display = 'none';
    }
}

function updateProgress() {
    const progressBar = document.querySelector('.progress');
    const questionCounter = document.querySelector('.question-counter');
    
    if (progressBar) {
        const progress = ((currentQuestion + 1) / questions.length) * 100;
        progressBar.style.width = `${progress}%`;
    }
    
    if (questionCounter) {
        questionCounter.textContent = `${currentQuestion + 1} / ${questions.length}`;
    }
}

function selectOption(selectedOption) {
    // Remove previous selections
    const options = document.querySelectorAll('.option');
    options.forEach(option => option.classList.remove('selected'));
    
    // Add selection to clicked option
    selectedOption.classList.add('selected');
    
    // Store answer
    const optionValue = selectedOption.getAttribute('data-option');
    userAnswers[currentQuestion] = optionValue;
}

function nextQuestion() {
    if (currentQuestion < questions.length - 1) {
        currentQuestion++;
        displayQuestion();
    }
}

function prevQuestion() {
    if (currentQuestion > 0) {
        currentQuestion--;
        displayQuestion();
    }
}

function showAnswer() {
    const question = questions[currentQuestion];
    const correctOption = document.querySelector(`[data-option="${String.fromCharCode(65 + question.correctAnswer)}"]`);
    const userOption = userAnswers[currentQuestion] ? 
        document.querySelector(`[data-option="${userAnswers[currentQuestion]}"]`) : null;
    
    // Show correct answer
    if (correctOption) {
        correctOption.classList.add('correct');
    }
    
    // Show incorrect if user selected wrong
    if (userOption && userOption !== correctOption) {
        userOption.classList.add('incorrect');
    }
    
    // Show explanation
    const explanationSection = document.getElementById('explanation-section');
    const explanationText = document.getElementById('explanation-text');
    
    if (explanationSection && explanationText) {
        explanationText.textContent = question.explanation;
        explanationSection.style.display = 'block';
    }
}

function submitQuiz() {
    // Calculate score
    score = 0;
    userAnswers.forEach((answer, index) => {
        if (answer && answer === String.fromCharCode(65 + questions[index].correctAnswer)) {
            score++;
        }
    });
    
    showResults();
}

function showResults() {
    const quizContainer = document.getElementById('quiz-container');
    const resultsSection = document.getElementById('results-section');
    
    if (quizContainer) quizContainer.style.display = 'none';
    if (resultsSection) resultsSection.style.display = 'block';
    
    // Update score display
    const finalScore = document.getElementById('final-score');
    const percentage = document.getElementById('percentage');
    const correctCount = document.getElementById('correct-count');
    const incorrectCount = document.getElementById('incorrect-count');
    
    if (finalScore) finalScore.textContent = score;
    if (percentage) percentage.textContent = Math.round((score / questions.length) * 100);
    if (correctCount) correctCount.textContent = score;
    if (incorrectCount) incorrectCount.textContent = questions.length - score;
    
    // Update grade
    const gradeElement = document.getElementById('grade');
    const percentageValue = Math.round((score / questions.length) * 100);
    
    if (gradeElement) {
        if (percentageValue >= 90) {
            gradeElement.innerHTML = '🏆 Outstanding (A+)';
            gradeElement.className = 'grade excellent';
        } else if (percentageValue >= 80) {
            gradeElement.innerHTML = '🌟 Excellent (A)';
            gradeElement.className = 'grade excellent';
        } else if (percentageValue >= 70) {
            gradeElement.innerHTML = '👍 Good (B)';
            gradeElement.className = 'grade good';
        } else if (percentageValue >= 60) {
            gradeElement.innerHTML = '👌 Fair (C)';
            gradeElement.className = 'grade fair';
        } else if (percentageValue >= 50) {
            gradeElement.innerHTML = '📚 Pass (D)';
            gradeElement.className = 'grade pass';
        } else {
            gradeElement.innerHTML = '💪 Keep Studying (F)';
            gradeElement.className = 'grade fail';
        }
    }
}

function restartQuiz() {
    currentQuestion = 0;
    userAnswers = [];
    score = 0;
    quizStarted = true;
    
    const quizContainer = document.getElementById('quiz-container');
    const resultsSection = document.getElementById('results-section');
    
    if (quizContainer) quizContainer.style.display = 'block';
    if (resultsSection) resultsSection.style.display = 'none';
    
    displayQuestion();
}

// Navigation Functions
function showQuizMode() {
    currentMode = 'quiz';
    hideAllSections();
    
    const quizIntro = document.getElementById('quiz-intro');
    const quizContainer = document.getElementById('quiz-container');
    
    if (quizIntro) quizIntro.style.display = 'block';
    
    updateActiveButton('quiz-btn');
    
    // Only show quiz container if quiz has started
    if (quizStarted) {
        if (quizContainer) quizContainer.style.display = 'block';
        displayQuestion();
    }
}

function showNotesMode() {
    currentMode = 'notes';
    hideAllSections();
    
    const notesSection = document.getElementById('notes-section');
    if (notesSection) notesSection.style.display = 'block';
    
    updateActiveButton('notes-btn');
}

function showMockTcaMode() {
    currentMode = 'mock-tca';
    hideAllSections();
    
    const mockTcaSection = document.getElementById('mock-tca-section');
    if (mockTcaSection) mockTcaSection.style.display = 'block';
    
    updateActiveButton('mock-tca-btn');
}

function hideAllSections() {
    const sections = ['quiz-intro', 'quiz-container', 'notes-section', 'mock-tca-section', 'results-section'];
    sections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) section.style.display = 'none';
    });
}

function updateActiveButton(activeId) {
    const buttons = ['quiz-btn', 'newq-quiz-btn', 'notes-btn', 'mock-tca-btn'];
    buttons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            if (btnId === activeId) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
    });
}

// Event Listeners Setup
function setupEventListeners() {
    // Option selection event listeners
    const options = document.querySelectorAll('.option');
    options.forEach(option => {
        option.addEventListener('click', () => selectOption(option));
    });

    // Navigation buttons
    const nextBtn = document.getElementById('next-btn');
    const prevBtn = document.getElementById('prev-btn');
    const submitBtn = document.getElementById('submit-btn');
    const showAnswerBtn = document.getElementById('show-answer-btn');
    const restartBtn = document.getElementById('restart-btn');
    const reviewBtn = document.getElementById('review-btn');

    if (nextBtn) nextBtn.addEventListener('click', nextQuestion);
    if (prevBtn) prevBtn.addEventListener('click', prevQuestion);
    if (submitBtn) submitBtn.addEventListener('click', submitQuiz);
    if (showAnswerBtn) showAnswerBtn.addEventListener('click', showAnswer);
    if (restartBtn) restartBtn.addEventListener('click', restartQuiz);
    if (reviewBtn) reviewBtn.addEventListener('click', () => {
        // Review functionality
        currentQuestion = 0;
        displayQuestion();
        const resultsSection = document.getElementById('results-section');
        const quizContainer = document.getElementById('quiz-container');
        if (resultsSection) resultsSection.style.display = 'none';
        if (quizContainer) quizContainer.style.display = 'block';
    });

    // Navigation mode buttons
    const quizBtn = document.getElementById('quiz-btn');
    const newqQuizBtn = document.getElementById('newq-quiz-btn');
    const notesBtn = document.getElementById('notes-btn');
    const mockTcaBtn = document.getElementById('mock-tca-btn');

    if (quizBtn) quizBtn.addEventListener('click', showQuizMode);
    if (newqQuizBtn) newqQuizBtn.addEventListener('click', () => {
        window.location.href = 'newquiz.html';
    });
    if (notesBtn) notesBtn.addEventListener('click', showNotesMode);
    if (mockTcaBtn) mockTcaBtn.addEventListener('click', showMockTcaMode);

    // TCA control buttons
    const startExamBtn = document.getElementById('start-exam-mode');
    const submitExamBtn = document.getElementById('submit-exam');
    const reviewExamBtn = document.getElementById('review-exam');
    const retakeExamBtn = document.getElementById('retake-exam');
    const showAllAnswersBtn = document.getElementById('show-all-answers');
    const resetTcaBtn = document.getElementById('reset-tca-quiz');

    if (startExamBtn) startExamBtn.addEventListener('click', startExamMode);
    if (submitExamBtn) submitExamBtn.addEventListener('click', () => submitExam(false));
    if (reviewExamBtn) reviewExamBtn.addEventListener('click', reviewExam);
    if (retakeExamBtn) retakeExamBtn.addEventListener('click', retakeExam);
    if (showAllAnswersBtn) showAllAnswersBtn.addEventListener('click', showAllAnswers);
    if (resetTcaBtn) resetTcaBtn.addEventListener('click', resetTCAQuiz);
}